# Pintos Project 3: 가상 메모리 (develop 브랜치 개요)

KAIST CS330 Pintos 커널의 develop 브랜치로, 프로젝트 3의 가상 메모리 확장 기능을 담고 있습니다. 해시 기반 보조 페이지 테이블과 지연 로딩, 스왑 공간, 파일 기반 매핑을 통해 수요 페이징과 `mmap`을 구현합니다.

## 저장소 구조
- `pintos/` – Pintos 소스 트리
  - `threads/` – 커널 스레드, 동기화 원시, 부트 코드
  - `userprog/` – 사용자 프로세스 로더와 시스템 콜 계층, 지연 로딩 진입점
  - `vm/` – 가상 메모리 핵심(프레임 테이블, 스왑, 파일 기반 페이지, 지연 페이지 초기화)
  - `filesys/` – 블록 디바이스와 파일 시스템 지원(파일 기반 페이지에서 참조)
  - `utils/` – 헬퍼 스크립트; Pintos 도구 실행 전 `PATH`에 추가해야 함

## 가상 메모리 설계

### 보조 페이지 테이블(SPT)
- 각 스레드는 해시 기반 SPT(`struct supplemental_page_table`)를 사용해 가상 주소와 `struct page` 메타데이터를 관리합니다.
- 페이지가 실제로 점유되거나 스왑 인되기 전까지 메타데이터만 지연 생성하며, 조회·삽입·삭제를 제공합니다.
- `fork` 시 부모의 SPT를 복사해 자식에게 페이지 메타데이터를 전달합니다.

### 프레임 관리와 교체
- 물리 프레임은 전역 `frame_table`과 `frame_lock`으로 관리합니다.
- 빈 프레임이 없으면 시계(세컨드 챈스) 알고리즘으로 희생 프레임을 고르고, 접근되지 않았거나 깨끗한 페이지를 우선 제거합니다.
- 희생 프레임은 페이지 매핑을 끊고, 파일 기반 페이지는 변경분을 기록하며 익명 페이지는 스왑으로 이동시킵니다.

### 익명 페이지 스왑
- 익명 페이지는 스왑 디스크(디바이스 `1:1`)의 페이지 크기 슬롯을 비트맵으로 추적합니다.
- 스왑 아웃은 페이지를 8섹터씩 빈 슬롯에 기록하고 PML4 엔트리를 비우며, 스왑 인은 새 프레임에 복원 후 슬롯을 해제합니다.
- 슬롯 할당과 회수는 경쟁을 막기 위해 `swap_lock`으로 보호합니다.

### 파일 기반 페이지와 mmap
- 파일 기반 페이지는 백킹 파일·오프셋·길이를 추적하며, 퇴출 시 더티 페이지는 파일로 플러시합니다.
- 실행 파일 구간과 사용자 `mmap` 모두 지연 로딩을 사용해 첫 접근 시에만 읽고 나머지는 제로로 채웁니다.
- `do_mmap`은 대상 파일을 재오픈하고 페이지별 읽기/제로 바이트 정보를 가진 `VM_FILE` 페이지를 배치합니다.
- `do_munmap`은 연속된 파일 기반 페이지를 순회하며 플러시 후 제거합니다.

### 지연 로딩과 스택 설정
- 실행 파일 구간은 페이지별 파일 오프셋·크기를 기억하고, `lazy_load_segment`가 첫 페이지 폴트 시 데이터를 복사해 채웁니다.
- 스택 초기화는 `USER_STACK - PGSIZE` 위치에 마커 페이지를 두고 즉시 클레임해, 초기 스택 포인터가 사용자 가상 메모리 상단에서 시작합니다.

## 빌드 및 실행
1. Pintos 트리로 이동해 스크립트를 노출합니다: `cd pintos && source activate`.
2. 특정 서브시스템(`threads`, `userprog`, `vm`, `filesys`)을 `make -C <dir>`로 빌드합니다. 최상위 `Makefile`은 공통 알림과 모든 서브트리의 `clean` 타깃을 제공합니다.
3. `activate`로 추가한 `utils/` 경로에서 `pintos`, `pintos-mkdisk` 등 도구를 실행합니다.
4. 적절한 서브디렉터리에서 `make check`로 테스트를 실행합니다(예: `make -C vm check TEST=swap-basic`).

## 참고
- Pintos 매뉴얼: https://casys-kaist.github.io/pintos-kaist/